import marimo

__generated_with = "0.13.15"
app = marimo.App(width="medium")


@app.cell
def _(mo):
    mo.md(r"""# Overview""")
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    The first three datasets (SynCAN, Car-Hacking, and Survival IDS) were used in the original LOCoCAT paper, and the analysis shown here was done to create blocks at that time.
    The purpose of this notebook is to show how we calculated those thresholds to create attack blocks, and to find the thresholds for the two new datasets that we might use in future work.

    This notebook takes a look at the CAN bus datasets we will use for attack classification.
    It reads all their attack datasets and analyzes the best way to create attack blocks for each of them.

    - The data files needed to run this notebook can be generated by running `python prepare_data.py --normal` file from the `src` directory.

    - If you just want to use the blocks created bt this analysis, you can create pre-labeled files with `python prepare_data.py --blocks`
    """
    )
    return


@app.cell
def _(mo):
    mo.md(r"""## Python Imports""")
    return


@app.cell
def _():
    import marimo as mo
    import matplotlib.pyplot as plt
    from os.path import join, pardir
    import pandas as pd
    import numpy as np
    return join, mo, pardir, pd, plt


@app.cell
def _(mo):
    mo.md(r"""# SynCAN Analysis""")
    return


@app.cell
def _(mo):
    run_button = mo.ui.run_button(label="Click to Run Analysis for the SynCAN Dataset")
    run_button
    return (run_button,)


@app.cell
def _(mo):
    mo.md(r"""## Prepare Data""")
    return


@app.cell
def _(join, mo, pardir, pd, run_button):
    mo.stop(not run_button.value, mo.md("Click the button above ðŸ‘† to run this and following cells"))

    pathname = join(pardir, "data", "syncan-all.csv")
    raw_data = pd.read_csv(pathname)
    raw_data
    return (raw_data,)


@app.cell
def _(raw_data):
    # Keep only the necessary columns.

    df = raw_data[["Time", "Label"]]
    df
    return (df,)


@app.cell
def _(df):
    # Find rows that are the start of a block.

    df["Start of Block"] = df["Label"] != df["Label"].shift(1).fillna(-1)
    df
    return


@app.cell
def _(df):
    # Number the blocks.

    df["Block Number"] = df["Start of Block"].cumsum()
    df
    return


@app.cell
def _(df, pd):
    # Find time difference to previous message in the same block.

    # Find diff to previous message.
    df["Time to Prev"] = df["Time"].diff(1)
    # Erase diff for the first message of each block.
    df.loc[df["Start of Block"] == True, "Time to Prev"] = pd.NA

    df
    return


@app.cell
def _(df, pd):
    # Find time information about the blocks.

    # Group the rows of the same block.
    blocks = df.groupby("Block Number")

    # Create an empty dataframe to store the information.
    grouped_df = pd.DataFrame()

    # Get the type of this block.
    grouped_df["Label"] = blocks["Label"].min()
    # Make sure there's only one label in the block.
    grouped_df["Unique Labels"] = blocks["Label"].nunique()
    # Timestamp of first message of the block
    grouped_df["Start"] = blocks["Time"].min()
    # Timestamp of last message of the block
    grouped_df["End"] = blocks["Time"].max()
    # Minimum difference between two messages of the same block.
    grouped_df["Min Intra Diff"] = blocks["Time to Prev"].min()
    # Maximum difference between two messages of the same block.
    grouped_df["Max Intra Diff"] = blocks["Time to Prev"].max()
    # Number of messages in the same block.
    grouped_df["Msg Count"] = blocks.size()

    grouped_df
    return (grouped_df,)


@app.cell
def _(grouped_df):
    # Find the difference between the end of a block and the start of the next one.

    grouped_df["Time To Next"] = grouped_df["Start"].shift(-1) - grouped_df["End"]
    grouped_df
    return


@app.cell
def _(mo):
    mo.md(r"""## Analysis""")
    return


@app.cell
def _(grouped_df):
    print("Single-Attack Blocks?", grouped_df['Unique Labels'].max() == grouped_df['Unique Labels'].min() == grouped_df['Unique Labels'].nunique() == 1)

    print()
    print()

    print("INTER BLOCK")
    print(f"Min time diff between two sequential blocks: {grouped_df['Time To Next'].min()}")
    print(f"Max time diff between two sequential blocks: {grouped_df['Time To Next'].max()}")

    print()
    print()

    print("INTRA BLOCK")
    print(f"Min time diff of sequential messages in a block: {grouped_df['Min Intra Diff'].min()}")
    print(f"Max time diff of sequential messages in a block: {grouped_df['Max Intra Diff'].max()}")
    print(f"Min block size in messages: {grouped_df['Msg Count'].min()}")
    print(f"Avg block size in messages: {grouped_df['Msg Count'].mean()}")
    print(f"Max block size in messages: {grouped_df['Msg Count'].max()}")
    print(f"Min block length in seconds: {(grouped_df['End'] - grouped_df['Start']).min()}")
    print(f"Avg block length in seconds: {(grouped_df['End'] - grouped_df['Start']).mean()}")
    print(f"Max block length in seconds: {(grouped_df['End'] - grouped_df['Start']).max()}")
    return


@app.cell
def _(grouped_df):
    # Remove normal data.

    attack_only = grouped_df[grouped_df["Label"] > 0]
    attack_only["Time To Next"] = attack_only["Start"].shift(-1) - attack_only["End"]
    attack_only
    return (attack_only,)


@app.cell
def _(attack_only):
    # Redo analysis with only attacks.

    print("Single-Attack Blocks?", attack_only['Unique Labels'].max() == attack_only['Unique Labels'].min() == attack_only['Unique Labels'].nunique() == 1)

    print()
    print()

    print("INTER BLOCK")
    print(f"Min time diff between two sequential blocks: {attack_only['Time To Next'].min()}")
    print(f"Max time diff between two sequential blocks: {attack_only['Time To Next'].max()}")

    print()
    print()

    print("INTRA BLOCK")
    print(f"Min time diff of sequential messages in a block: {attack_only['Min Intra Diff'].min()}")
    print(f"Max time diff of sequential messages in a block: {attack_only['Max Intra Diff'].max()}")
    print(f"Min block size in messages: {attack_only['Msg Count'].min()}")
    print(f"Avg block size in messages: {attack_only['Msg Count'].mean()}")
    print(f"Max block size in messages: {attack_only['Msg Count'].max()}")
    print(f"Min block length in seconds: {(attack_only['End'] - attack_only['Start']).min()}")
    print(f"Avg block length in seconds: {(attack_only['End'] - attack_only['Start']).mean()}")
    print(f"Max block length in seconds: {(attack_only['End'] - attack_only['Start']).max()}")
    return


@app.cell
def _(mo):
    mo.md(r"""## Takeaways""")
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    ### Without filtering
    If using ***all the data*** for syncan, then we cannot find a attack split factor since the time difference between two messages of the same block can be larger than the distance between two separate blocks. In that case, you would have to use the data grouped based on the "Start of Block" like we did above and disregard the time between blocks.

    From the literature, it is fair assume that we can detect between normal and attack data near-instantly, so as long as there are no mixed message labels in each block (i.e., there is at least one normal message between every two attack messages of different type), then it is fine to analyze this data with the grouping we've done above.


    ### With filtering
    If using ***only attack data*** for syncan, then we have a large space between different blocks, much larger than intra-difference between messages. In that case, we could use an attack split factor of:
    """
    )
    return


@app.cell
def _(attack_only):
    (attack_only['Time To Next'].min() + attack_only['Max Intra Diff'].max()) / 2
    return


@app.cell
def _(mo):
    mo.md(r"""# Car-Hacking Analysis""")
    return


@app.cell
def _(mo):
    ch_run_button = mo.ui.run_button(label="Click to Run Analysis for the Car-Hacking Dataset")
    ch_run_button
    return (ch_run_button,)


@app.cell
def _(mo):
    mo.md(r"""## Prepare Data""")
    return


@app.cell
def _(ch_run_button, join, mo, pardir, pd):
    mo.stop(not ch_run_button.value, mo.md("Click the button above ðŸ‘† to run this and following cells"))

    ch_pathname = join(pardir, "data", "car_hacking-all.csv")
    ch_raw_data = pd.read_csv(ch_pathname)
    ch_raw_data
    return (ch_raw_data,)


@app.cell
def _(ch_raw_data):
    # Remove unnecessary columns.
    ch_df = ch_raw_data[["Time", "Label"]]
    ch_df
    return (ch_df,)


@app.cell
def _(ch_df):
    # Find rows that are the start of a block.
    ch_df["Start of Block"] = ch_df["Label"] != ch_df["Label"].shift(1).fillna(-1)
    ch_df
    return


@app.cell
def _(ch_df):
    # Number the blocks.
    ch_df["Block Number"] = ch_df["Start of Block"].cumsum()
    ch_df
    return


@app.cell
def _(ch_df, pd):
    # Find time difference to previous message in the same block.

    # Find diff to previous message.
    ch_df["Time to Prev"] = ch_df["Time"].diff(1)
    # Erase diff for the first message of each block.
    ch_df.loc[ch_df["Start of Block"] == True, "Time to Prev"] = pd.NA

    ch_df
    return


@app.cell
def _(ch_df, pd):
    # Find time information about the blocks.

    # Group the rows of the same block.
    ch_blocks = ch_df.groupby("Block Number")

    # Create an empty dataframe to store the information.
    ch_grouped_df = pd.DataFrame()

    # Get the type of this block.
    ch_grouped_df["Label"] = ch_blocks["Label"].min()
    # Make sure there's only one label in the block.
    ch_grouped_df["Unique Labels"] = ch_blocks["Label"].nunique()
    # Timestamp of first message of the block
    ch_grouped_df["Start"] = ch_blocks["Time"].min()
    # Timestamp of last message of the block
    ch_grouped_df["End"] = ch_blocks["Time"].max()
    # Minimum difference between two messages of the same block.
    ch_grouped_df["Min Intra Diff"] = ch_blocks["Time to Prev"].min()
    # Maximum difference between two messages of the same block.
    ch_grouped_df["Max Intra Diff"] = ch_blocks["Time to Prev"].max()
    # Number of messages in the same block.
    ch_grouped_df["Msg Count"] = ch_blocks.size()

    ch_grouped_df
    return (ch_grouped_df,)


@app.cell
def _(ch_grouped_df):
    # Find the difference between the end of a block and the start of the next one.

    ch_grouped_df["Time To Next"] = ch_grouped_df["Start"].shift(-1) - ch_grouped_df["End"]
    ch_grouped_df
    return


@app.cell
def _(mo):
    mo.md(r"""## Analysis""")
    return


@app.cell
def _(ch_grouped_df):
    print("Single-Attack Blocks?", ch_grouped_df['Unique Labels'].max() == ch_grouped_df['Unique Labels'].min() == ch_grouped_df['Unique Labels'].nunique() == 1)

    print()
    print()

    print("INTER BLOCK")
    print(f"Min time diff between two sequential blocks: {ch_grouped_df['Time To Next'].min()}")
    print(f"Max time diff between two sequential blocks: {ch_grouped_df['Time To Next'].max()}")

    print()
    print()

    print("INTRA BLOCK")
    print(f"Min time diff of sequential messages in a block: {ch_grouped_df['Min Intra Diff'].min()}")
    print(f"Max time diff of sequential messages in a block: {ch_grouped_df['Max Intra Diff'].max()}")
    print(f"Min block size in messages: {ch_grouped_df['Msg Count'].min()}")
    print(f"Avg block size in messages: {ch_grouped_df['Msg Count'].mean()}")
    print(f"Max block size in messages: {ch_grouped_df['Msg Count'].max()}")
    print(f"Min block length in seconds: {(ch_grouped_df['End'] - ch_grouped_df['Start']).min()}")
    print(f"Avg block length in seconds: {(ch_grouped_df['End'] - ch_grouped_df['Start']).mean()}")
    print(f"Max block length in seconds: {(ch_grouped_df['End'] - ch_grouped_df['Start']).max()}")
    return


@app.cell
def _(ch_grouped_df):
    # Remove normal data.

    ch_attack_only = ch_grouped_df[ch_grouped_df["Label"] > 0]
    ch_attack_only["Time To Next"] = ch_attack_only["Start"].shift(-1) - ch_attack_only["End"]
    ch_attack_only
    return (ch_attack_only,)


@app.cell
def _(ch_attack_only):
    # Redo analysis with only attacks.

    print("Single-Attack Blocks?", ch_attack_only['Unique Labels'].max() == ch_attack_only['Unique Labels'].min() == ch_attack_only['Unique Labels'].nunique() == 1)

    print()
    print()

    print("INTER BLOCK")
    print(f"Min time diff between two sequential blocks: {ch_attack_only['Time To Next'].min()}")
    print(f"Max time diff between two sequential blocks: {ch_attack_only['Time To Next'].max()}")

    print()
    print()

    print("INTRA BLOCK")
    print(f"Min time diff of sequential messages in a block: {ch_attack_only['Min Intra Diff'].min()}")
    print(f"Max time diff of sequential messages in a block: {ch_attack_only['Max Intra Diff'].max()}")
    print(f"Min block size in messages: {ch_attack_only['Msg Count'].min()}")
    print(f"Avg block size in messages: {ch_attack_only['Msg Count'].mean()}")
    print(f"Max block size in messages: {ch_attack_only['Msg Count'].max()}")
    print(f"Min block length in seconds: {(ch_attack_only['End'] - ch_attack_only['Start']).min()}")
    print(f"Avg block length in seconds: {(ch_attack_only['End'] - ch_attack_only['Start']).mean()}")
    print(f"Max block length in seconds: {(ch_attack_only['End'] - ch_attack_only['Start']).max()}")
    return


@app.cell
def _(mo):
    mo.md(r"""## Initial Takeaway""")
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    The blocks are not as nicely created as for the SynCAN, as many of them have a single message in it -- this indicates that in this dataset, there are non-attack messages interleaved with attack ones.
    Thus, we have to find a better way to group them.
    """
    )
    return


@app.cell
def _(mo):
    mo.md(r"""## Extra Analysis""")
    return


@app.cell
def _(mo):
    mo.md(r"""Let's look at only the attack messages, and see if we can find a "cooldown period" between a sequence of messages:""")
    return


@app.cell
def _(ch_raw_data):
    # Get the individual attack messages from the dataset.
    ch_attack_messages = ch_raw_data[ch_raw_data["Label"] > 0]
    ch_attack_messages
    return (ch_attack_messages,)


@app.cell
def _(ch_attack_messages):
    # Sort them based on time and find the difference to the next one.
    ch_attack_messages_sorted = ch_attack_messages.sort_values(by=["Time"])[["Time", "Label"]]
    ch_attack_messages_sorted
    return (ch_attack_messages_sorted,)


@app.cell
def _(ch_attack_messages_sorted):
    ch_attack_messages_sorted["Time to Prev"] = ch_attack_messages_sorted["Time"].diff(1)
    ch_attack_messages_sorted
    return


@app.cell
def _(ch_attack_messages_sorted, plt):
    # Filter some of the time diffs.
    ch_filtered_diffs = ch_attack_messages_sorted[
        # Remove the super high values created by our data pre-processing.
        (ch_attack_messages_sorted["Time to Prev"] < 1_000_000_000)
    ]["Time to Prev"]

    # Create a histogram so we can see the distribution of time differences.
    plt.hist(ch_filtered_diffs.reset_index(drop=True))
    plt.yscale('log')
    plt.show()
    return


@app.cell
def _(mo):
    mo.md(r"""## Final Takeaway""")
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    From the histogram above, we can see that there is a very big difference in the two ends.
    Based on the dataset and CAN bus attack characteristics, it is a fair assumption that the larger differences (in the 3,000 bin) are the "cooldown periods" between different attacks.

    So, in order to group the individual messages into attack blocks like in the LOCoCAT paper, we can use a an `attack_split_factor` in the range [1000, 2500].
    """
    )
    return


@app.cell
def _(mo):
    mo.md(r"""# Survival IDS Analysis""")
    return


@app.cell
def _(mo):
    si_run_button = mo.ui.run_button(label="Click to Run Analysis for the Survival IDS Dataset")
    si_run_button
    return (si_run_button,)


@app.cell
def _(mo):
    mo.md(r"""## Prepare Data""")
    return


@app.cell
def _(join, mo, pardir, pd, si_run_button):
    mo.stop(not si_run_button.value, mo.md("Click the button above ðŸ‘† to run this and following cells"))

    si_pathname = join(pardir, "data", "survival_ids-all.csv")
    si_raw_data = pd.read_csv(si_pathname)
    si_raw_data
    return (si_raw_data,)


@app.cell
def _(si_raw_data):
    # Remove unnecessary columns.
    si_df = si_raw_data[["Time", "Label"]]
    si_df
    return (si_df,)


@app.cell
def _(si_df):
    # Find rows that are the start of a block.
    si_df["Start of Block"] = si_df["Label"] != si_df["Label"].shift(1).fillna(-1)
    si_df
    return


@app.cell
def _(si_df):
    # Number the blocks.
    si_df["Block Number"] = si_df["Start of Block"].cumsum()
    si_df
    return


@app.cell
def _(pd, si_df):
    # Find time difference to previous message in the same block.

    # Find diff to previous message.
    si_df["Time to Prev"] = si_df["Time"].diff(1)
    # Erase diff for the first message of each block.
    si_df.loc[si_df["Start of Block"] == True, "Time to Prev"] = pd.NA

    si_df
    return


@app.cell
def _(pd, si_df):
    # Find time information about the blocks.

    # Group the rows of the same block.
    si_blocks = si_df.groupby("Block Number")

    # Create an empty dataframe to store the information.
    si_grouped_df = pd.DataFrame()

    # Get the type of this block.
    si_grouped_df["Label"] = si_blocks["Label"].min()
    # Make sure there's only one label in the block.
    si_grouped_df["Unique Labels"] = si_blocks["Label"].nunique()
    # Timestamp of first message of the block
    si_grouped_df["Start"] = si_blocks["Time"].min()
    # Timestamp of last message of the block
    si_grouped_df["End"] = si_blocks["Time"].max()
    # Minimum difference between two messages of the same block.
    si_grouped_df["Min Intra Diff"] = si_blocks["Time to Prev"].min()
    # Maximum difference between two messages of the same block.
    si_grouped_df["Max Intra Diff"] = si_blocks["Time to Prev"].max()
    # Number of messages in the same block.
    si_grouped_df["Msg Count"] = si_blocks.size()

    si_grouped_df

    return (si_grouped_df,)


@app.cell
def _(si_grouped_df):
    # Find the difference between the end of a block and the start of the next one.

    si_grouped_df["Time To Next"] = si_grouped_df["Start"].shift(-1) - si_grouped_df["End"]
    si_grouped_df
    return


@app.cell
def _(mo):
    mo.md(r"""## Analysis""")
    return


@app.cell
def _(si_grouped_df):
    print("Single-Attack Blocks?", si_grouped_df['Unique Labels'].max() == si_grouped_df['Unique Labels'].min() == si_grouped_df['Unique Labels'].nunique() == 1)

    print()
    print()

    print("INTER BLOCK")
    print(f"Min time diff between two sequential blocks: {si_grouped_df['Time To Next'].min()}")
    print(f"Max time diff between two sequential blocks: {si_grouped_df['Time To Next'].max()}")

    print()
    print()

    print("INTRA BLOCK")
    print(f"Min time diff of sequential messages in a block: {si_grouped_df['Min Intra Diff'].min()}")
    print(f"Max time diff of sequential messages in a block: {si_grouped_df['Max Intra Diff'].max()}")
    print(f"Min block size in messages: {si_grouped_df['Msg Count'].min()}")
    print(f"Avg block size in messages: {si_grouped_df['Msg Count'].mean()}")
    print(f"Max block size in messages: {si_grouped_df['Msg Count'].max()}")
    print(f"Min block length in seconds: {(si_grouped_df['End'] - si_grouped_df['Start']).min()}")
    print(f"Avg block length in seconds: {(si_grouped_df['End'] - si_grouped_df['Start']).mean()}")
    print(f"Max block length in seconds: {(si_grouped_df['End'] - si_grouped_df['Start']).max()}")
    return


@app.cell
def _(si_grouped_df):
    # Remove normal data.

    si_attack_only = si_grouped_df[si_grouped_df["Label"] > 0]
    si_attack_only["Time To Next"] = si_attack_only["Start"].shift(-1) - si_attack_only["End"]
    si_attack_only
    return (si_attack_only,)


@app.cell
def _(si_attack_only):
    # Redo analysis with only attacks.

    print("Single-Attack Blocks?", si_attack_only['Unique Labels'].max() == si_attack_only['Unique Labels'].min() == si_attack_only['Unique Labels'].nunique() == 1)

    print()
    print()

    print("INTER BLOCK")
    print(f"Min time diff between two sequential blocks: {si_attack_only['Time To Next'].min()}")
    print(f"Max time diff between two sequential blocks: {si_attack_only['Time To Next'].max()}")

    print()
    print()

    print("INTRA BLOCK")
    print(f"Min time diff of sequential messages in a block: {si_attack_only['Min Intra Diff'].min()}")
    print(f"Max time diff of sequential messages in a block: {si_attack_only['Max Intra Diff'].max()}")
    print(f"Min block size in messages: {si_attack_only['Msg Count'].min()}")
    print(f"Avg block size in messages: {si_attack_only['Msg Count'].mean()}")
    print(f"Max block size in messages: {si_attack_only['Msg Count'].max()}")
    print(f"Min block length in seconds: {(si_attack_only['End'] - si_attack_only['Start']).min()}")
    print(f"Avg block length in seconds: {(si_attack_only['End'] - si_attack_only['Start']).mean()}")
    print(f"Max block length in seconds: {(si_attack_only['End'] - si_attack_only['Start']).max()}")
    return


@app.cell
def _(mo):
    mo.md(r"""## Initial Takeaway""")
    return


@app.cell
def _(mo):
    mo.md(r"""These results are similar to the Car-Hacking ones, which indicates further analysis is required.""")
    return


@app.cell
def _(mo):
    mo.md(r"""## Extra Analysis""")
    return


@app.cell
def _(plt, si_raw_data):
    # Get the individual attack messages from the dataset.
    si_attack_messages = si_raw_data[si_raw_data["Label"] > 0]

    # Sort them based on time and find the difference to the next one.
    si_attack_messages_sorted = si_attack_messages.sort_values(by=["Time"])[["Time", "Label"]]

    # Find the difference from one message to the next one.
    si_attack_messages_sorted["Time to Prev"] = si_attack_messages_sorted["Time"].diff(1)

    # Filter some of the time diffs.
    si_filtered_diffs = si_attack_messages_sorted[
        # Remove the super high values created by our data pre-processing.
        (si_attack_messages_sorted["Time to Prev"] < 1_000_000_000)
    ]["Time to Prev"]

    # Create a histogram so we can see the distribution of time differences.
    plt.hist(si_filtered_diffs.reset_index(drop=True))
    plt.yscale('log')
    plt.show()
    return


@app.cell
def _(mo):
    mo.md(r"""## Final Takeaway""")
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    From the histogram above, we can see that there are three separate blocks. The first one depicts the messages that are in the same attack, while the "middle" and "right" ones are the cooldown periods.

    So, in order to group the individual messages into attack blocks like in the LOCoCAT paper, we can use a an `attack_split_factor` in the range [2000, 4000].
    """
    )
    return


@app.cell
def _(mo):
    mo.md(r"""# can-ml Analysis""")
    return


@app.cell
def _(mo):
    cm_run_button = mo.ui.run_button(label="Click to Run Analysis for the can-ml Dataset")
    cm_run_button
    return (cm_run_button,)


@app.cell
def _(mo):
    mo.md(r"""## Prepare Data""")
    return


@app.cell
def _(cm_run_button, join, mo, pardir, pd):
    mo.stop(not cm_run_button.value, mo.md("Click the button above ðŸ‘† to run this and following cells"))

    cm_pathname = join(pardir, "data", "can_ml-all.csv")
    cm_raw_data = pd.read_csv(cm_pathname)
    cm_raw_data
    return (cm_raw_data,)


@app.cell
def _(cm_raw_data):
    # Remove unnecessary columns.
    cm_df = cm_raw_data[["Time", "Label"]]
    cm_df
    return (cm_df,)


@app.cell
def _(cm_df):
    # Find rows that are the start of a block.
    cm_df["Start of Block"] = cm_df["Label"] != cm_df["Label"].shift(1).fillna(-1)
    cm_df
    return


@app.cell
def _(cm_df):
    # Number the blocks.
    cm_df["Block Number"] = cm_df["Start of Block"].cumsum()
    cm_df
    return


@app.cell
def _(cm_df, pd):
    # Find time difference to previous message in the same block.

    # Find diff to previous message.
    cm_df["Time to Prev"] = cm_df["Time"].diff(1)
    # Erase diff for the first message of each block.
    cm_df.loc[cm_df["Start of Block"] == True, "Time to Prev"] = pd.NA

    cm_df
    return


@app.cell
def _(cm_df, pd):
    # Find time information about the blocks.

    # Group the rows of the same block.
    cm_blocks = cm_df.groupby("Block Number")

    # Create an empty dataframe to store the information.
    cm_grouped_df = pd.DataFrame()

    # Get the type of this block.
    cm_grouped_df["Label"] = cm_blocks["Label"].min()
    # Make sure there's only one label in the block.
    cm_grouped_df["Unique Labels"] = cm_blocks["Label"].nunique()
    # Timestamp of first message of the block
    cm_grouped_df["Start"] = cm_blocks["Time"].min()
    # Timestamp of last message of the block
    cm_grouped_df["End"] = cm_blocks["Time"].max()
    # Minimum difference between two messages of the same block.
    cm_grouped_df["Min Intra Diff"] = cm_blocks["Time to Prev"].min()
    # Maximum difference between two messages of the same block.
    cm_grouped_df["Max Intra Diff"] = cm_blocks["Time to Prev"].max()
    # Number of messages in the same block.
    cm_grouped_df["Msg Count"] = cm_blocks.size()

    cm_grouped_df

    return (cm_grouped_df,)


@app.cell
def _(cm_grouped_df):
    # Find the difference between the end of a block and the start of the next one.

    cm_grouped_df["Time To Next"] = cm_grouped_df["Start"].shift(-1) - cm_grouped_df["End"]
    cm_grouped_df
    return


@app.cell
def _(mo):
    mo.md(r"""## Analysis""")
    return


@app.cell
def _(cm_grouped_df):
    print("Single-Attack Blocks?", cm_grouped_df['Unique Labels'].max() == cm_grouped_df['Unique Labels'].min() == cm_grouped_df['Unique Labels'].nunique() == 1)

    print()
    print()

    print("INTER BLOCK")
    print(f"Min time diff between two sequential blocks: {cm_grouped_df['Time To Next'].min()}")
    print(f"Max time diff between two sequential blocks: {cm_grouped_df['Time To Next'].max()}")

    print()
    print()

    print("INTRA BLOCK")
    print(f"Min time diff of sequential messages in a block: {cm_grouped_df['Min Intra Diff'].min()}")
    print(f"Max time diff of sequential messages in a block: {cm_grouped_df['Max Intra Diff'].max()}")
    print(f"Min block size in messages: {cm_grouped_df['Msg Count'].min()}")
    print(f"Avg block size in messages: {cm_grouped_df['Msg Count'].mean()}")
    print(f"Max block size in messages: {cm_grouped_df['Msg Count'].max()}")
    print(f"Min block length in seconds: {(cm_grouped_df['End'] - cm_grouped_df['Start']).min()}")
    print(f"Avg block length in seconds: {(cm_grouped_df['End'] - cm_grouped_df['Start']).mean()}")
    print(f"Max block length in seconds: {(cm_grouped_df['End'] - cm_grouped_df['Start']).max()}")
    return


@app.cell
def _(cm_grouped_df):
    # Remove normal data.

    cm_attack_only = cm_grouped_df[cm_grouped_df["Label"] > 0]
    cm_attack_only["Time To Next"] = cm_attack_only["Start"].shift(-1) - cm_attack_only["End"]
    cm_attack_only
    return (cm_attack_only,)


@app.cell
def _(cm_attack_only):
    # Redo analysis with only attacks.

    print("Single-Attack Blocks?", cm_attack_only['Unique Labels'].max() == cm_attack_only['Unique Labels'].min() == cm_attack_only['Unique Labels'].nunique() == 1)

    print()
    print()

    print("INTER BLOCK")
    print(f"Min time diff between two sequential blocks: {cm_attack_only['Time To Next'].min()}")
    print(f"Max time diff between two sequential blocks: {cm_attack_only['Time To Next'].max()}")

    print()
    print()

    print("INTRA BLOCK")
    print(f"Min time diff of sequential messages in a block: {cm_attack_only['Min Intra Diff'].min()}")
    print(f"Max time diff of sequential messages in a block: {cm_attack_only['Max Intra Diff'].max()}")
    print(f"Min block size in messages: {cm_attack_only['Msg Count'].min()}")
    print(f"Avg block size in messages: {cm_attack_only['Msg Count'].mean()}")
    print(f"Max block size in messages: {cm_attack_only['Msg Count'].max()}")
    print(f"Min block length in seconds: {(cm_attack_only['End'] - cm_attack_only['Start']).min()}")
    print(f"Avg block length in seconds: {(cm_attack_only['End'] - cm_attack_only['Start']).mean()}")
    print(f"Max block length in seconds: {(cm_attack_only['End'] - cm_attack_only['Start']).max()}")
    return


@app.cell
def _(mo):
    mo.md(r"""## Intitial Takeaway""")
    return


@app.cell
def _(mo):
    mo.md(r"""Similarly to the `Car-Hacking` and `Survival-IDS` datasets, we need further analysis to see if these blocks are separable.""")
    return


@app.cell
def _(mo):
    mo.md(r"""## Extra Analysis""")
    return


@app.cell
def _(cm_raw_data, plt):
    # Get the individual attack messages from the dataset.
    cm_attack_messages = cm_raw_data[cm_raw_data["Label"] > 0]

    # Sort them based on time and find the difference to the next one.
    cm_attack_messages_sorted = cm_attack_messages.sort_values(by=["Time"])[["Time", "Label"]]

    # Find the difference from one message to the next one.
    cm_attack_messages_sorted["Time to Prev"] = cm_attack_messages_sorted["Time"].diff(1)

    # Filter some of the time diffs.
    cm_filtered_diffs = cm_attack_messages_sorted[
        # Remove the super high values created by our data pre-processing.
        (cm_attack_messages_sorted["Time to Prev"] < 1_000_000_000)
    ]["Time to Prev"]

    # Create a histogram so we can see the distribution of time differences.
    plt.hist(cm_filtered_diffs.reset_index(drop=True))
    plt.yscale('log')
    plt.show()
    return (cm_attack_messages_sorted,)


@app.cell
def _(mo):
    mo.md(
        r"""
    This first try does not seem to yield very good results unlike for the previous datasets.
    After analyzing the dataset, it appears that each file contains all messages of the same attack, so it would make sense to use the `timeshift` we added as the threshold for these attacks.
    """
    )
    return


@app.cell
def _(cm_attack_messages_sorted, plt):
    # Create a histogram so we can see the distribution of time differences without removing the timeshift we introduced.
    plt.hist(cm_attack_messages_sorted["Time to Prev"])
    plt.yscale('log')
    plt.show()
    return


@app.cell
def _(mo):
    mo.md(r"""## Final Takeaway""")
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    For the `can-ml` dataset, we should consider all messages of each attack file as a single block.
    To do so, we can use an `attack_split_factor` of around $2,500,000,000,000$ ($0.25 * 10^{13}$) to separate the `can_ml-all.csv` file into appropriate blocks.
    """
    )
    return


@app.cell
def _(mo):
    mo.md(r"""# CAN-MIRGU Analysis""")
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    This dataset is easier to analyze -- it comes with a metadata file detailing all different attacks in it!


    The `prepare_data` script already assigns the correct block labels to each attack; the data is loaded below so you can see that each row already has a Block field that you can use to group them.
    """
    )
    return


@app.cell
def _(mo):
    cmirgu_run_button = mo.ui.run_button(label="Click to Run Analysis for the CAN-MIRGU Dataset")
    cmirgu_run_button
    return (cmirgu_run_button,)


@app.cell
def _(cmirgu_run_button, join, mo, pardir, pd):
    mo.stop(not cmirgu_run_button.value, mo.md("Click the button above ðŸ‘† to run this and following cells"))

    cmirgu_pathname = join(pardir, "data", "can_mirgu-blocks.csv")
    cmirgu_raw_data = pd.read_csv(cmirgu_pathname)
    cmirgu_raw_data
    return


if __name__ == "__main__":
    app.run()
